/*
You'll need the following things to make this demo work:

- TLS certificate files (e.g., from `certbot` or `mkcert`):
  - demo/localhost+2-key.pem
  - demo/localhost+2.pem
- Environment variables:
  - NODE_EXTRA_CA_CERTS = "$(mkcert -CAROOT)/rootCA.pem" (only if using certificates generated by `mkcert`)
*/

import { BaseExpressWebApp } from "../src/index.mjs"
import { execSync } from "node:child_process"
import { FileDB } from "@jrc03c/filedb"
import { Mailer } from "../src/utils/mailer/mailer.mjs"
import { MailerResponse } from "../src/utils/mailer/mailer-response.mjs"
import { watch } from "@jrc03c/watch"
import express from "express"
import fs from "node:fs"
import helmet from "helmet"
import https from "node:https"
import path from "node:path"

class DummyMailer extends Mailer {
  async send(payload) {
    base.logger.logWarning(payload.text)

    try {
      execSync(`echo "${payload.text.split(":").at(-1).trim()}" | xsel -b`, {
        encoding: "utf8",
      })
    } catch (e) {}

    return new MailerResponse(true)
  }
}

const privateDir = path.join(import.meta.dirname, "private")

if (!fs.existsSync(privateDir)) {
  fs.mkdirSync(privateDir, { recursive: true })
}

const base = new BaseExpressWebApp({
  database: new FileDB({ path: privateDir }),
  mailer: new DummyMailer(),
})

const app = express()

// apply basic security measures
app.disable("x-powered-by")
app.use(helmet())

app.post("/authn/register", base.handlers.authentication.register)
app.post("/authn/verify-password", base.handlers.authentication.verifyPassword)
app.post("/authn/change-password", base.handlers.authentication.changePassword)
app.post("/authn/send-otp-email", base.handlers.authentication.sendOTPEmail)
app.post("/authn/verify-otp", base.handlers.authentication.verifyOTP)
app.post("/authn/sign-out", base.handlers.authentication.signOut)
app.post("/authn/delete-account", base.handlers.authentication.deleteAccount)
app.post("/db/read", base.handlers.database.read)
app.post("/db/write", base.handlers.database.write)

app.post("/authn/is-signed-in", async (request, response) => {
  return response.send(await base.requestIsAuthorized(request))
})

// here we create a relaxed helmet instance that allows us to serve the vue
// app without complaint from the browser (note that this is *only* for the
// statically-served content)
const relaxedHelmet = helmet({
  contentSecurityPolicy: {
    directives: {
      ...helmet.contentSecurityPolicy.getDefaultDirectives(),
      "script-src": ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
    },
  },
})

app.use(
  "/",
  relaxedHelmet,
  express.static(path.join(import.meta.dirname, "public"), {
    extensions: ["html"],
  }),
)

const httpsServer = (() => {
  const config = {
    key: fs.readFileSync(path.join(import.meta.dirname, "localhost+2-key.pem")),
    cert: fs.readFileSync(path.join(import.meta.dirname, "localhost+2.pem")),
  }

  return https.createServer(config, app)
})()

httpsServer.listen(8443, () => {
  console.log("Visit: https://localhost:8443")
})

const mainJsFile = path.join(
  import.meta.dirname,
  "public",
  "res",
  "js",
  "src",
  "main.mjs",
)

const mainJsBundleFile = path.join(
  import.meta.dirname,
  "public",
  "res",
  "js",
  "bundle.js",
)

function rebuild() {
  try {
    base.logger.logInfo("Rebuilding...")

    execSync(
      `npx esbuild ${mainJsFile} --bundle --outfile=${mainJsBundleFile} --define:__VUE_OPTIONS_API__=true --define:__VUE_PROD_DEVTOOLS__=false --define:__VUE_PROD_HYDRATION_MISMATCH_DETAILS__=false`,
      {
        encoding: "utf8",
      },
    )

    base.logger.logSuccess("Rebuilt! ðŸŽ‰")
  } catch (e) {
    base.logger.logError(e)
  }
}

watch({
  target: path.join(import.meta.dirname, "public/res/js/src"),
  created: rebuild,
  modified: rebuild,
  deleted: rebuild,
})

rebuild()
